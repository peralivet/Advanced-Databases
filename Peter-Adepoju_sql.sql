 
 --================================================================================================================
 --                         START OF TASK 2
 --================================================================================================================
/* QUESTION 1 */

/* PART 1 */

-- Use master to create database
USE master;
/* The following code creates a new database called LibraryManagementSystem */
CREATE DATABASE LibraryManagementSystem; 
-- Creating the database
use LibraryManagementSystem;
-- Creating a new schema
CREATE SCHEMA ClientLibrary;
 

 /* Creating the various lookup tables */
 -- lookup table for the item type 
CREATE TABLE ClientLibrary.Item_Type_Lookup 
(
-- auto-incrementing primary key for each item type
Item_Type_ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
Item_Name NVARCHAR(50) NOT NULL UNIQUE -- name of the item type, maximum length of 50 characters
);
 -- lookup table for the Status Name  
CREATE TABLE ClientLibrary.Current_Status_Lookup 
(
-- Unique ID for each status which will be Autogenerated
Status_ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
-- Status name like On Loan, Overdue, Available or Lost/Removed
Status_Name NVARCHAR(50) NOT NULL UNIQUE
);

 -- lookup table for the payment method 
CREATE TABLE ClientLibrary.Payment_Method_Lookup 
(
-- Unique ID for each payment which will be Autogenerated
Payment_ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
-- Payment name like cash or card or any future name
Payment_Name NVARCHAR(50) NOT NULL UNIQUE
);

-- Creating the Member Category Lookup table 
CREATE TABLE ClientLibrary.Member_Category 
(
CategoryID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, -- auto-incrementing primary key for each category
CategoryName NVARCHAR(50) NOT NULL, -- Category Name
CategoryDesc NVARCHAR(100) NULL -- Category Description
); 

-- Creating the Member subscription status Lookup table 
CREATE TABLE ClientLibrary.Subscription_Status
(
-- auto-incrementing primary key for each Subscription status
Subscription_Status_ID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
StatusName NVARCHAR(50) NOT NULL UNIQUE-- Subscription Status Name 
); 


/* Creating the Member table */
CREATE TABLE ClientLibrary.Member 
(
-- auto-incrementing primary key for each member
MemberID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
-- first name of member, maximum length of 30 characters
FirstName NVARCHAR(30) NOT NULL, 
 -- last name of member, maximum length of 30 characters
LastName NVARCHAR(30) NOT NULL,
MemberDOB DATE NOT NULL, -- date of birth of member 
EmailAddress NVARCHAR(100) , -- email address of member
-- phone number of member, maximum length of 20 characters
PhoneNumber NVARCHAR(20), 
-- username of member, maximum length of 60 characters
Username NVARCHAR(60) UNIQUE NOT NULL, 
-- this column will contain hashed characters, maximum length of 64 characters
PasswordHash NVARCHAR(64) NOT NULL, 
-- checking that a correct email format is entered
CONSTRAINT CK_Email CHECK (EmailAddress LIKE '%_@__%.__%') 
); 
 
/* Creating the Addresses which will hold different address */ 
CREATE TABLE ClientLibrary.Addresses 
(
-- Unique ID for each address
AddressID INT IDENTITY(1,1)  NOT NULL PRIMARY KEY, 
Address1 NVARCHAR(100) NOT NULL, -- Address line 1 of the member
Address2 NVARCHAR(50) NULL, -- Address line 2 of the member
City NVARCHAR(50) NULL, -- City of the member
A_State NVARCHAR(50) NULL, -- state of the member
Country NVARCHAR(50) NULL, -- Country of the member
Postcode NVARCHAR(10) NOT NULL -- Postcode of the member 
);

/* Creating the member_addresses table to link members to their addresses */ 
CREATE TABLE ClientLibrary.Member_addresses 
(
Mem_addressID INT IDENTITY(1,1)  NOT NULL PRIMARY KEY,
-- foreign key field that references the ID field in the members table
member_id INT NOT NULL, 
-- foreign key field that references the ID field in the addresses table
address_id INT NOT NULL, 
Address_type NVARCHAR(20), -- The type of address(Home,office,Billing,Shipping)
-- create the foreign key relationship to the members table
FOREIGN KEY (member_id) REFERENCES ClientLibrary.Member(MemberID), 
-- create the foreign key relationship to the addresses table
FOREIGN KEY (address_id) REFERENCES ClientLibrary.Addresses(AddressID) 
);
/*  Code to create the Member Subscription table */
CREATE TABLE ClientLibrary.Member_Subscription
(
-- auto-incrementing primary key for subscription
SubscriptionID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
-- foreign key field that references the ID field in the members table
MemberID INT NOT NULL, 
Membership_Start_Date DATE, -- date when member's membership started
Membership_Expiration_Date DATE, -- date when member's membership expires 
Subscription_Status_ID INT NOT NULL, -- Foreign key field Subscription_Status table
MemberCategoryID INT NOT NULL, -- Foreign key references Member_Category table
Subscription_charge money, -- amount the subscription is costing
 -- foreign key constraint for MemberCategoryID column
CONSTRAINT ck_fk_mem_memcat FOREIGN KEY (MemberCategoryID) 
      REFERENCES ClientLibrary.Member_Category (CategoryID),
-- foreign key constraint for MemberID column
CONSTRAINT ck_fk_membersubcription_mid FOREIGN KEY (MemberID)
   REFERENCES ClientLibrary.Member (MemberID) ,
-- foreign key constraint for subscription status ID column
CONSTRAINT ck_fk_membersubcription_statusid FOREIGN KEY (Subscription_Status_ID) 
            REFERENCES ClientLibrary.Subscription_Status (Subscription_Status_ID) 
);

/*  Code to create the Member Login table */
CREATE TABLE ClientLibrary.Member_Login 
(
-- auto-incrementing primary key for each login record
LoginID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
MemberID INT NOT NULL, -- foreign key reference to the Member table
 -- date and time of login, default value is current date and time
Login_time DATETIME2 NOT NULL DEFAULT (GETDATE()),
-- IP address of device used for login
Ip_address NVARCHAR(30) NOT NULL, 
-- user agent string of device used for login
User_agent NVARCHAR(80) NOT NULL, 
-- foreign key constraint for MemberID column
CONSTRAINT ck_fk_memberLog_mid FOREIGN KEY (MemberID) 
  REFERENCES ClientLibrary.Member (MemberID) 
);


/* Creating the Item Table */
CREATE TABLE ClientLibrary.Item 
(
ItemID INT IDENTITY(1,1) NOT NULL PRIMARY KEY,  -- Autogenerated ItemID 
ItemTypeID INT NOT NULL,  -- Foreign key to the ItemTypeLookup table to indicate the type of item 
ItemTitle NVARCHAR(70) NOT NULL,  -- Title of the item 
Author NVARCHAR(70) NOT NULL,  -- Author of the item 
PublishedYear INT NOT NULL,  -- Original published date of the item
-- Check constraint to ensure that ItemTypeID is a valid ItemType_ID in ItemTypeLookup table
CONSTRAINT ckfkitemitemtype FOREIGN KEY (ItemTypeID) REFERENCES ClientLibrary.Item_Type_Lookup(Item_Type_ID)  
);


/* Creating the ItemCopy Table */
CREATE TABLE ClientLibrary.ItemCopy 
(
-- Unique ID for each item copy which will be Autogenerated
CopyID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, 
ItemID INT NOT NULL,  -- ID of the item that this copy belongs to
Date_Added DATE NOT NULL,   -- Date on which this copy was added to the library
Status_ID INT Default 1, -- ID of the current status of the item copy. Default Status(available)
Lost_Removed_date DATE, -- Date on which this copy was lost or removed from the library
ISBN NVARCHAR(70), -- ISBN number when applicable
PublishedYear INT,  -- Year the item was published(if different)
-- Foreign key to the Current_Status_Lookup table for data integrity
CONSTRAINT ck_item_status FOREIGN KEY (Status_ID)  REFERENCES ClientLibrary.Current_Status_Lookup(Status_ID), 
-- Foreign key to the Item table to ensure that only valid item IDs are inserted into this column
CONSTRAINT ck_fk_itemcopy_itemID  FOREIGN KEY (ItemID) REFERENCES ClientLibrary.Item(ItemID) 
); 


   
/* Creating the Loan Table */
CREATE TABLE ClientLibrary.Loan 
(
LoanID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, -- Unique ID for each Loan which will be Autogenerated
MemberID INT NOT NULL, -- Identifier for the member who borrowed the item
CopyID INT NOT NULL, -- Identifier for the item copy that was borrowed
Date_Taken_Out DATE NOT NULL, -- Date on which the item was borrowed
Date_Due_Back DATE NOT NULL, -- Due date for returning the item
Date_Returned DATE, -- Date on which the item was returned (nullable)
FineAmount MONEY, -- Amount of fine charged for late return (nullable)
FineBalance MONEY, -- Amount left to pay 
-- Foreign key constraint to ensure that MemberID references a valid MemberID in the Member table
CONSTRAINT ck_loan_memberID FOREIGN KEY (MemberID) REFERENCES ClientLibrary.Member (MemberID),
-- Foreign key constraint to ensure that CopyID references a valid CopyID in the ItemCopy table
CONSTRAINT ck_loan_item_copyid FOREIGN KEY (CopyID) REFERENCES ClientLibrary.ItemCopy (CopyID)
);


/* Creating the Repayment Table  */
CREATE TABLE ClientLibrary.Fine_Repayment
( 
RepaymentID INT IDENTITY(1,1) NOT NULL PRIMARY KEY, -- Unique ID for each repayment which will be Autogenerated
LoanID INT NOT NULL, -- Identifier for the loan that the fine repayment is associated with
Memberid INT NOT NULL, -- Identifier for the member who made the fine repayment
AmountPaid MONEY NOT NULL,  -- Amount of the fine that was paid
PaymentDate DATE NOT NULL, -- Date on which the fine was paid
PaymentID INT NOT NULL, -- Identifier for the payment method that was used to make the fine repayment
-- Foreign key constraint to ensure that LoanID references a valid LoanID in the Loan table
CONSTRAINT chkfineIdreplace FOREIGN KEY (LoanID)  REFERENCES ClientLibrary.Loan (LoanID),
-- Foreign key constraint to ensure that PaymentID references a valid PaymentID in the PaymentMethodLookup table
CONSTRAINT chkpaymentidreplace FOREIGN KEY (PaymentID)  REFERENCES ClientLibrary.Payment_Method_Lookup(Payment_ID),
-- Foreign key constraint to ensure that Memberid references a valid MemberID in the Member table
CONSTRAINT chkmemidreplace FOREIGN KEY (Memberid) REFERENCES ClientLibrary.Member (MemberID)
); 
 
 

-- PART 2
-- 2a
/*
 One of the client requirements is to be able to search the item catalogue for matching character 
 strings by item title. Results should be sorted with the most recent publication date first.
  Which will allow them to query the catalogue looking for a specific item. */
 
 /* View that search item catalogue by matching character */
 GO 
CREATE PROCEDURE ClientLibrary.SP_SearchItemCatalogueByTitle
    @searchTerm NVARCHAR(50)
AS
BEGIN
    SELECT i.ItemTitle 'Item Title',i.Author 'Item Author',
            -- I'm picking the item copy published date first
            -- incase it's different from the original one
            ISNULL(c.PublishedYear,i.PublishedYear) 'Published Year',
            l.Item_Name 'Item Name'
    FROM ClientLibrary.Itemcopy c -- I'm returning the copies of the item
    JOIN  ClientLibrary.Item i 
    on c.itemID = i.itemID -- joining item to itemcopy
    JOIN ClientLibrary.Item_Type_Lookup l 
    ON i.ItemTypeID = l.Item_Type_ID --joining the item lookup table for the item type name
    WHERE i.ItemTitle LIKE '%' + @searchTerm + '%' -- search for the character match
     -- ordering it by the most recent published year
    ORDER BY  ISNULL(c.PublishedYear,i.PublishedYear) DESC;
END;




-- 2(b)
/* The next task is to return a full list of all items currently on loan which have a due date of
fewer than five days from the current date (i.e., the system date when the query is run).  */
/* item on loan due in less that five days */
GO 
CREATE VIEW ClientLibrary.VW_GetFullItemListDueSoon
AS 
    SELECT 
            CONCAT(m.FirstName,' ',m.LastName) 'Member Full Name',
            i.ItemTitle 'Item Title',i.Author 'Item Author',i.PublishedYear 'Published Year',
            t.Item_Name 'Item Name',l.Date_Taken_Out 'Loan Date', l.Date_Due_Back 'Loan Date Due', 
            DATEDIFF(day,GETDATE(),Date_Due_Back) AS 'Days Left To Return(From Today)'     
    FROM Loan l
    JOIN ClientLibrary.ItemCopy c
    ON l.CopyID = c.CopyID -- joining the loan and itemcopy table
    JOIN ClientLibrary.item i
    ON i.ItemID = c.ItemID -- joining the item and itemcopy table
    JOIN ClientLibrary.Item_Type_Lookup t
    ON t.Item_Type_ID = i.ItemTypeID --joining the item lookup table for the item type name 
    JOIN ClientLibrary.member m
    ON m.memberID = l.MemberID -- joining the loan to the member table
    WHERE c.Status_ID   =  
        -- using subquery to find the status id of "on loan" items
        (SELECT Status_ID FROM ClientLibrary.Current_Status_Lookup WHERE Status_Name = 'On Loan')
    AND DATEDIFF(day,GETDATE(),Date_Due_Back) < 5
    AND DATEDIFF(day,GETDATE(),Date_Due_Back) >= 0 ; -- to avoid longer negative days
GO


 
-- 2(c) inserting into the member table
/* Stored procedure to insert into member information */
GO 
CREATE PROCEDURE ClientLibrary.SP_InsertMember
    -- various parameter passed to the stored procedure for insertion
    @FirstName NVARCHAR(30),@LastName NVARCHAR(30),@MemberDOB DATE,
    @EmailAddress NVARCHAR(100) = NULL, @PhoneNumber NVARCHAR(20) = NULL, 
    @Username NVARCHAR(60), @PasswordH NVARCHAR(64), @Address1 NVARCHAR(50),
    @Address2 NVARCHAR(50) = NULL, @City NVARCHAR(50)= NULL,
    @A_State NVARCHAR(50)= NULL,  @Country NVARCHAR(50)= NULL,
    @Postcode NVARCHAR(10),  @Address_type NVARCHAR(20)
AS
BEGIN
    
     /* When SET NOCOUNT is turned on, SQL Server does not send the message 
     indicating the number of rows affected by a Transact-SQL statement to the 
     client, which can reduce network traffic and improve the performance of querie */
    SET NOCOUNT ON;
    
    BEGIN TRY
        BEGIN TRANSACTION; -- start of transaction

        DECLARE @AddressID INT;
        DECLARE @MemberID INT;
        -- for Database security, I'm using Hasbytes to store the password passed to the procedure
        DECLARE @hashedPassword NVARCHAR(100) = 
                            CONVERT(NVARCHAR(100), HASHBYTES('SHA2_256', @PasswordH), 2)

        -- Insert address
        INSERT INTO ClientLibrary.Addresses (Address1, Address2, City, A_State, Country, Postcode)
        VALUES (@Address1, @Address2, @City, @A_State, @Country, @Postcode);

        -- Get the ID of the inserted address
        SET @AddressID = SCOPE_IDENTITY();

        -- Insert member
        INSERT INTO ClientLibrary.Member (FirstName, LastName, MemberDOB, EmailAddress, 
                                          PhoneNumber,Username, PasswordHash)
        VALUES (@FirstName, @LastName, @MemberDOB, @EmailAddress, @PhoneNumber,
                @Username, @hashedPassword);

        -- Get the ID of the inserted member
        SET @MemberID = SCOPE_IDENTITY();

        -- Insert member's address
        INSERT INTO ClientLibrary.Member_addresses (member_id, address_id, Address_type)
        VALUES (@MemberID, @AddressID, @Address_type);

        -- view the various records inserted
        -- Viewing the member's table after Insertion
        SELECT * FROM ClientLibrary.member 
        WHERE MemberID = @MemberID; -- Member table
        SELECT * FROM ClientLibrary.addresses 
        WHERE AddressID = @AddressID; -- address table
        SELECT * FROM ClientLibrary.member_addresses 
        WHERE member_id = @MemberID; -- member address
        COMMIT TRANSACTION; -- commit the transaction
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION; -- rollback transaction if it fails
        THROW;
    END CATCH;
END; 

GO

-- 2(d)
/* Updating a member information */
CREATE PROCEDURE SP_UpdateMember
    @memberID INT,
    @firstName VARCHAR(50),
    @lastName VARCHAR(50),
    @email VARCHAR(50),
    @phoneNumber VARCHAR(20)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;
        -- updating member record
        UPDATE ClientLibrary.Member
        SET FirstName = @firstName,
            LastName = @lastName,
            EmailAddress = @email,
            PhoneNumber = @phoneNumber
        WHERE MemberID = @memberID;
        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END;
 

 /* QUESTION 3 
The library wants be able to view the loan history, showing all previous and current loans, 
and including details of the item borrowed, borrowed date, due date and any associated fines for 
each loan. You should create a view containing all the required information.*/ 
/* View showing the previous and current loan history */
GO
CREATE VIEW ClientLibrary.VW_LoanHistory AS 

-- view query
SELECT 
        -- selecting various column
         m.FirstName + ' ' + m.LastName AS 'Member Name'
        ,i.ItemTitle AS 'Item Title'
        ,l.Date_Taken_Out AS 'Borrowed Date'
        ,l.Date_Due_Back AS 'Due Date'
        ,l.Date_Returned AS 'Returned Date'
        ,l.FineAmount 'Total Loan Fine Amount' -- each day due attracts 10p
        -- Getting the sum of all repayment for this loan on the fine_repayment table
        , sum(isnull(f.AmountPaid,0.00)) 'Total Fine Paid' 
        ,sum(isnull(l.FineBalance,0.00))  'Loan Fine Balance' -- loan Balance
        ,CASE  
             -- I'm using this logic to clasify a loan as current since item not has been returned 
                WHEN l.Date_Returned IS NULL then 'Current Loan' 
                -- I'm using this logic to clasify a loan as previous since item has been returned 
                WHEN   l.Date_Returned IS NOT NULL AND l.Date_Due_Back <=  GETDATE() 
                        THEN 'Previous Loan'  
                ELSE 'OTHER'
         END AS 'Loan Status'
-- Joining various tables
FROM ClientLibrary.Loan l
JOIN ClientLibrary.ItemCopy c ON l.CopyID = c.CopyID 
JOIN ClientLibrary.Item i ON i.ItemID = c.ItemID
JOIN ClientLibrary.Member m ON m.MemberID = l.MemberID
LEFT JOIN ClientLibrary.Fine_Repayment f ON l.LoanID = f.LoanID
GROUP BY
m.FirstName + ' ' + m.LastName ,
       i.ItemTitle , l.Date_Taken_Out , l.Date_Due_Back , l.Date_Returned,l.finebalance,l.FineAmount  ;
 
 GO
 



 /* QUESTION 4 */ 
/*4. Create triggers so that the current status of an item automatically updates to Overdue if the item has not
 been returned by the due date, and so that the current status updates to Available when the book is returned.*/
/* Trigger to update item status to available or overdue    */
GO
CREATE TRIGGER ClientLibrary.TRG_UpdateItemStatus
ON ClientLibrary.Loan
AFTER INSERT, UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        BEGIN TRANSACTION;
        -- Update status to Available when the book is returned
        UPDATE ClientLibrary.ItemCopy
        SET Status_ID =
              -- Available status
             (SELECT Status_ID from  ClientLibrary.Current_Status_Lookup WHERE Status_Name = 'Available')
        FROM  inserted i
        INNER JOIN ClientLibrary.Loan l ON i.LoanID = l.LoanID
        INNER JOIN ClientLibrary.ItemCopy c ON l.CopyID = c.CopyID
        WHERE l.Date_Returned IS NOT NULL
        AND c.Status_ID IN 
                 -- Only update if status is On Loan or Overdue
                (SELECT Status_ID from  ClientLibrary.Current_Status_Lookup WHERE Status_Name IN ('On Loan','Overdue')); 

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        -- If an error occurs, roll back the transaction and print an error message
        ROLLBACK TRANSACTION;
        PRINT ERROR_MESSAGE();
    END CATCH;
END;


 /* QUESTION 5 
 5. You should provide a function, view, or SELECT query which allows the library to 
identify the total number of loans made on a specified date.
*/ 
-- Function to return the number of loans on a specific date  
GO
CREATE FUNCTION ClientLibrary.Func_GetLoansOnDate (@loanDate DATE)
RETURNS INT
AS
BEGIN
    DECLARE @numLoans INT;

    SELECT @numLoans = COUNT(*) --count the number of rows
    FROM ClientLibrary.Loan
    -- loan date that matches the parameter passed
    WHERE CONVERT(DATE, Date_Taken_Out) = @loanDate; 
    RETURN @numLoans; -- returns the count
END;

GO

 

/* QUESTION 6 

Question 6 comes after all objects has been created */
 
 

--- Question 7
/* 
This view display all the Loan items that are currently overdue, along with the member who 
borrowed them and the amount of the overdue fine. This view selects information from the 
loan, member, item, itemcopy, and Item_Type_Lookup tables to show details of overdue items. 
The overdue fee calculation assumes a rate of 10p per day(which is based on clients requirement),
 and the view only includes items that are currently on loan and overdue.
 */
-- 7.1.1 Views(Loan Items currently Overdue)
GO
CREATE VIEW ClientLibrary.VW_OverDueLoanItems
AS
SELECT  
            CONCAT(m.FirstName,' ',m.LastName) 'Member Full Name',
            i.ItemTitle 'Item Title',
            i.Author 'Item Author',
            i.PublishedYear 'Published Year',
            t.Item_Name 'Item Name',
            l.Date_Taken_Out 'Loan Date', 
            l.Date_Due_Back 'Loan Date Due',  
    CASE 
        -- item is overdue and item is not returned
        WHEN l.Date_Returned IS NULL AND l.Date_Due_Back < GETDATE() THEN  
            DATEDIFF(day, l.Date_Due_Back, GETDATE())  -- number of days overdue
        ELSE 
            0 
    END AS 'Days Overdue',
    l.FineAmount 'Overdue Fee'

FROM ClientLibrary.Loan l
    JOIN ClientLibrary.ItemCopy c
    ON l.CopyID = c.CopyID -- joining the loan and itemcopy table
    JOIN ClientLibrary.item i
    ON i.ItemID = c.ItemID -- joining the item and itemcopy table
    JOIN ClientLibrary.Item_Type_Lookup t
    ON t.Item_Type_ID = i.ItemTypeID --joining the item lookup table for the item type name 
    JOIN ClientLibrary.member m
    ON m.memberID = l.MemberID -- joining the loan to the member table 

WHERE 
    l.date_returned IS NULL  --item not returned
    AND l.Date_Due_Back < GETDATE(); -- return date is less than today
GO

-- 7.1.2 Daily Overdue Items
/* 
This view display all the items that are due for every single day along with the member who 
borrowed them and the amount of the overdue fine. This view selects information from the 
loan, member, item, itemcopy, and Item_Type_Lookup tables to show details of overdue items. 
The overdue fee calculation assumes a rate of 10p per day(which is based on clients requirement),
 and the view only includes items that are currently on loan and overdue.
 */

CREATE VIEW ClientLibrary.VW_DailyDueLoanItems
AS
SELECT  
            CONCAT(m.FirstName,' ',m.LastName) 'Member Full Name',
            i.ItemTitle 'Item Title',
            i.Author 'Item Author',
            i.PublishedYear 'Published Year',
            t.Item_Name 'Item Name',
            l.Date_Taken_Out 'Loan Date', 
            l.Date_Due_Back 'Loan Date Due',  
    CASE 
        -- item is overdue and item is not returned
        WHEN l.Date_Returned IS NULL AND l.Date_Due_Back < GETDATE() THEN  
            DATEDIFF(day, l.Date_Due_Back, GETDATE())  -- number of days overdue
        ELSE 
            0 
    END AS 'Days Overdue',
    l.FineAmount 'Overdue Fee'

FROM ClientLibrary.Loan l
    JOIN ClientLibrary.ItemCopy c
    ON l.CopyID = c.CopyID -- joining the loan and itemcopy table
    JOIN ClientLibrary.item i
    ON i.ItemID = c.ItemID -- joining the item and itemcopy table
    JOIN ClientLibrary.Item_Type_Lookup t
    ON t.Item_Type_ID = i.ItemTypeID --joining the item lookup table for the item type name 
    JOIN ClientLibrary.member m
    ON m.memberID = l.MemberID -- joining the loan to the member table 

WHERE 
    l.date_returned IS NULL  --item not returned
    AND l.Date_Due_Back = GETDATE(); -- return date is today
GO


-- 7.1.3 View Lost/Removed item copy
/* 
This view display all the items that are lost or removed.
 */

CREATE VIEW ClientLibrary.VW_LostRemovedItemCopy
AS
SELECT  
            i.ItemTitle 'Item Title', 
            i.Author 'Item Author',
            isnull(c.PublishedYear,i.PublishedYear) 'Published Year',
            CONVERT(NVARCHAR, c.Date_Added , 106) 'Date Added To Library',
            CONVERT(NVARCHAR, c.[Lost_Removed_date]  , 106) 'Lost/Removed Date',
            c.ISBN   
FROM  ClientLibrary.item i
    JOIN ClientLibrary.ItemCopy c
    ON i.ItemID = c.ItemID -- joining the item and itemcopy table

WHERE c.[Lost_Removed_date] IS NOT NULL -- itemcopy lost/removed    
GO

-- 7.1.4 Top 10  Member who borrowed from the library
/* 
This view display the top 10 Members who borrows from the library.
 */
CREATE VIEW ClientLibrary.VW_Top10LoanMembers
AS
SELECT TOP 10   CONCAT(m.FirstName,' ',m.LastName) 'Member Full Name',
                 COUNT(l.LoanID) 'Number Of Loans' -- Counting loans
FROM ClientLibrary.Loan l
    JOIN ClientLibrary.member m
    ON m.memberID = l.MemberID -- joining the loan to the member table 
GROUP BY CONCAT(m.FirstName,' ',m.LastName)
ORDER BY COUNT(l.LoanID) DESC -- Order it from the highest to the lowest loan count
GO

 

-- 7.2 Stored Procedure:

/* 7.2.1 
I'm creating this store procedure which can be 
run daily before the start of business to update the 
FineAmount for every loan */
 
GO
CREATE PROCEDURE ClientLibrary.SP_DailyUpdateLoanFineAmount
AS
BEGIN
    BEGIN TRY
        DECLARE @CurrentDate DATE = GETDATE(); -- the current day 
        DECLARE @LoanID INT, @DueDate DATE, @FineAmount MONEY,
                @FineBalance MONEY, @returnDate DATE; 

        DECLARE LoandCursor CURSOR FOR
            -- selecting data from the loan table
            SELECT LoanID, Date_Due_Back, FineAmount,FineBalance,Date_Returned
            FROM ClientLibrary.Loan; 
            --loading the selected data into the cursor
        OPEN LoandCursor;
        -- fetch the first record in the cursor
        FETCH NEXT FROM LoandCursor INTO @LoanID, @DueDate, @FineAmount,@FineBalance,@returnDate;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            -- Setting fine amount
            SET @FineAmount = 
                CASE
                    -- item overdue and item not yet returned
                    WHEN @DueDate <= @CurrentDate AND @returnDate IS NULL 
                        THEN DATEDIFF(DAY, @DueDate, @CurrentDate) * 0.10
                    -- item overdue and item returned
                    WHEN @DueDate <= @returnDate AND @returnDate IS NOT NULL
                        THEN DATEDIFF(DAY, @DueDate, @returnDate) * 0.10
                    -- set fine to 0 if loan is not due
                    WHEN @DueDate > @CurrentDate THEN 0
                    -- Item returned Early
                    WHEN  @returnDate <= @DueDate AND @returnDate IS NOT NULL THEN 0
                    -- anything else, set to 0
                    ELSE 0
                END;

                 -- Setting fine balance(for the first time)
            SET @FineBalance = 
                CASE
                    --balance is null
                    WHEN @FineBalance IS NULL THEN 0
                    -- balance is not null
                    ELSE @FineBalance
                END;
            -- update the loan table with the right fine 
            UPDATE ClientLibrary.Loan SET 
                FineAmount = @FineAmount,
                FineBalance = @FineBalance
            WHERE LoanID = @LoanID;
            -- fetch the next record in the cursor
            FETCH NEXT FROM LoandCursor INTO @LoanID, @DueDate, @FineAmount,@FineBalance,@returnDate;
        END

        CLOSE LoandCursor;
        DEALLOCATE LoandCursor;
    END TRY
    BEGIN CATCH
        -- display error in case of update error 
        SELECT ERROR_MESSAGE() AS ErrorMessage;
    END CATCH
END;
GO

/* 7.2.2 Stored Procedure:
this Procedure updates the item status to lost/removed
and updates the ISBN if the item is a book */

GO
CREATE PROCEDURE UpdateItemCopyStatusAndISBN
    @IN_CopyID INT,
    @lost_remove_date DATE,
    @IN_ISBN NVARCHAR(20) = NULL
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        BEGIN TRANSACTION;
        -- update the status 
        UPDATE ClientLibrary.ItemCopy
        SET Status_ID = 
        -- set statusId to Lost/Removed
        (SELECT Status_ID from  ClientLibrary.Current_Status_Lookup WHERE Status_Name = 'Lost/Removed'),
        -- set lost_remove_date to 
         Lost_Removed_date = @lost_remove_date
        WHERE CopyID = @IN_CopyID;
        -- check to see if the item copy is a book
        IF EXISTS (SELECT * FROM ClientLibrary.ItemCopy ic JOIN ClientLibrary.item i ON ic.ItemID = i.ItemID 
                    WHERE ic.CopyID = @IN_CopyID 
                    AND i.ItemTypeID = (select Item_Type_ID from ClientLibrary.Item_Type_Lookup where Item_Name = 'Book') ) 
        BEGIN
             -- because it's a book, update the ISBN column
            UPDATE ClientLibrary.ItemCopy
            SET ISBN = @IN_ISBN
            WHERE CopyID =  @IN_CopyID;
        END

        COMMIT TRANSACTION;
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;
        THROW;
    END CATCH
END;
GO



-- 7.3 User-Defined Function
/*
This function takes in a loan ID and calculates the number of days the loan is overdue by 
subtracting the due date from the current date. If the loan is overdue, the function calculates 
the overdue fine at a rate of 10p per day. If the loan is not overdue, the function returns a value of 0.
 */

GO
CREATE FUNCTION ClientLibrary.Func_CalculateOverdueFineAmount
(
    @loanID INT
)
RETURNS NVARCHAR(100)
AS
BEGIN
    DECLARE @overdueDays INT, @overdueFine MONEY, @date_borrow DATE
    -- selecting the day it was borrowed
    SELECT @date_borrow =   Date_Taken_Out 
    FROM ClientLibrary.Loan
    WHERE LoanID = @loanID
    -- selecting the days overdue
    SELECT @overdueDays = DATEDIFF(DAY, Date_Due_Back, GETDATE())
    FROM ClientLibrary.Loan
    WHERE LoanID = @loanID
    -- calculating fine per 10p a day 
    IF @overdueDays > 0
    BEGIN
        SELECT @overdueFine = @overdueDays * 0.10
    END
    ELSE
    BEGIN
        SELECT @overdueFine = 0
    END   
    -- return the fine
    RETURN CONCAT('This Item was borrowed on: ', @date_borrow ,' and has a fine of : ',@overdueFine)
END;
GO



-- 7.4 Trigger

/* 7.4.1 Update Fine Balance Trigger 
This trigger updates the FineBalance in the Loan table when a repayment is made in the 
Fine_Repayment table.It uses a transaction to ensure that the update is atomic and 
either fully committed or fully rolled back in case of an error
*/

GO
CREATE TRIGGER ClientLibrary.TRG_UpdateFineBalance
ON ClientLibrary.Fine_Repayment
AFTER INSERT -- after insert on fine_repayment table
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @LoanID INT; -- loan id
    DECLARE @AmountPaid MONEY; -- amount repaid
    DECLARE @FineAmount MONEY; -- fine Amount on the loan
    BEGIN TRY
        BEGIN TRAN; -- Begin transaction
        -- Get the LoanID and AmountPaid for the inserted repayment
        SELECT @LoanID = LoanID, @AmountPaid = AmountPaid
        FROM inserted;
        -- Get the current FineAmount for the loan
        SELECT @FineAmount = FineAmount
        FROM ClientLibrary.Loan
        WHERE LoanID = @LoanID;
        -- Throw an error if FineAmount is null
        IF @FineAmount IS NULL
            THROW 50001, 'Fine amount cannot be null, 
                        Run SP_DailyUpdateLoanFineAmount Stored Procedure', 1;
        -- Update the FineBalance in the Loan table
        -- Update the FineBalance in the Loan table
        UPDATE ClientLibrary.Loan
        -- Take fineamount from total repayment
        SET FineBalance = 
            CASE WHEN @FineAmount IS NULL THEN NULL -- fine amount not set yet
                 -- fine amount is set yet
                 ELSE  ISNULL(@FineAmount,0) - 
                                                -- selecting total fine paid for this loan
                                                (SELECT ISNULL(SUM(AmountPaid),0) 
                                                   FROM ClientLibrary.Fine_Repayment 
                                                   WHERE loanID = @LoanID)
                END 
        WHERE LoanID = @LoanID;
        COMMIT TRAN; -- Commit transaction
    END TRY
    BEGIN CATCH
        -- If there is any error, rollback the transaction and show the error message
        IF @@TRANCOUNT > 0
            ROLLBACK TRAN;
        THROW;
    END CATCH
END;

/*7.4.2 Update Item Copy Status Trigger 
 this trigger updates the status of an item to on loan once
   there's an insert of the item copy in the loan table */
GO
CREATE TRIGGER ClientLibrary.TRG_UpdateItemCopyStatus
ON ClientLibrary.Loan
AFTER INSERT
AS
BEGIN
  SET NOCOUNT ON;
  BEGIN TRY
    BEGIN TRANSACTION;
    
    -- Update the status of the corresponding item copies in the ItemCopy table
    UPDATE ItemCopy
    SET Status_ID = (
      -- Change the status to "On Loan"
      SELECT Status_ID FROM ClientLibrary.Current_Status_Lookup WHERE Status_Name = 'On Loan'
    )
    FROM ItemCopy -- Join the ItemCopy table
    JOIN inserted ON ItemCopy.CopyID = inserted.CopyID; -- Only update the inserted row(s) in the Loan table
    
    COMMIT TRANSACTION; -- commit the transaction if there's no error
  END TRY
  BEGIN CATCH
    IF @@TRANCOUNT > 0
      ROLLBACK TRANSACTION; -- rollback if error is encountered
      
    -- Log the error message
    DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
    RAISERROR('Error occurred in TRG_UpdateItemCopyStatus: %s', 16, 1, @ErrorMessage);
  END CATCH;
END; 
GO

/* Question 6 */

/* The Following insert helped me in the testing of my
SELECT queries, user-defined functions, stored procedures, and triggers */

-- Inserting records into Item Lookup table
INSERT INTO ClientLibrary.Item_Type_Lookup (Item_Name) 
VALUES ('Book'), ('DVD'),('CD'),('Other Media'); 

-- Inserting records into status Lookup table
INSERT INTO ClientLibrary.Current_Status_Lookup (Status_Name) 
VALUES ('Available'),('On Loan'),('Overdue'),('Lost/Removed') ; 

-- Inserting records into Payment_Method Lookup table
INSERT INTO ClientLibrary.Payment_Method_Lookup (Payment_Name) VALUES ('Cash'),('Card'); 

-- Inserting records into Member_Category Lookup table
INSERT INTO ClientLibrary.Member_Category (CategoryName, CategoryDesc) 
VALUES ('Basic', 'Basic membership category')
,('Premium', 'Premium membership category');

-- Inserting records into Subscription status Lookup table
INSERT INTO ClientLibrary.Subscription_Status 
VALUES('Active'), ('INACTIVE'),('END');
     


-- Insert  new member 1
EXEC ClientLibrary.SP_InsertMember @FirstName = 'Ken',@LastName = 'Angel',@MemberDOB = '1967-10-10',
    @EmailAddress = 'ken.angel@magic.com',@PhoneNumber = '078495484', @Username = 'ken.angel',
    @PasswordH = 'Kennyangel*1',@Address1 = 'Helside Daytun',
    @Address2 = NULL,@City = 'Dayton',@A_State = 'Utah',@Country = 'USA',@Postcode = '99032',
    @Address_type = 'Home';

-- Sign Up MemberID(1) 
INSERT INTO ClientLibrary.Member_Subscription(MemberID,Membership_Start_Date,Membership_Expiration_Date,
                                             Subscription_Status_ID,MemberCategoryID,Subscription_charge)
VALUES(1,GETDATE(),NULL,1,2,20);

-- Insert new member 2
EXEC ClientLibrary.SP_InsertMember @FirstName = 'Dr',@LastName = 'NathnAr',@MemberDOB = '1983-05-15',
    @EmailAddress = 'drnatsa@salforduni.com',@PhoneNumber = '07495984895',@Username = 'dr.nathan',
    @PasswordH = 'NathyNat*1',@Address1 = 'SSEE Building, Salford Crescent',
    @Address2 = NULL,@City = 'Salford',@A_State = 'Manchester',@Country = 'UK',@Postcode = 'M54WT',
    @Address_type = 'Office';

-- Sign Up Member(2)  
INSERT INTO ClientLibrary.Member_Subscription(MemberID,Membership_Start_Date,Membership_Expiration_Date,
                                              Subscription_Status_ID,MemberCategoryID,Subscription_charge)
VALUES(1,GETDATE(),NULL,1,1,10);  


-- Inserting records into member login audit
INSERT INTO ClientLibrary.Member_Login(MemberID, Ip_address, User_agent)
VALUES (1, '192.168.1.100', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'),
     (2, '192.168.1.101', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '),
      (1, '192.168.1.110', 'Andriod'),
     (2, '192.168.1.121', 'Iphone');

-- Inserting records into  item table
INSERT INTO ClientLibrary.Item (ItemTypeID, ItemTitle, Author, PublishedYear) 
VALUES (1, 'To Kill a Mockingbird', 'Harper Lee', 1960),
(1, 'Gideon Spies', 'Ben Hayta', 2015),
(2, 'The Godfather', 'Mario Puzo', 1969)
,(3, 'Graduation', 'Kanye West', 2008);

-- Inserting records into itemcopy(Available Items)
INSERT INTO ClientLibrary.ItemCopy (ItemID, Date_Added, Status_ID, Lost_Removed_date, ISBN,PublishedYear)
VALUES  (2, '2022-01-10', 3, NULL, NULL,NULL),
        (1, '2023-02-11', 3, NULL, NULL,NULL),
        (3, '2008-11-21', 3, NULL, NULL,NULL),
        (2, '2022-01-01', 3, NULL, NULL,2001),
        (1, '2023-01-01', 3, NULL, NULL,NULL),
        (3, '2010-11-11', 3, NULL, NULL,NULL)   ; 
 
-- Inserting records into itemcopy(On loan  Items)
INSERT INTO ClientLibrary.ItemCopy (ItemID, Date_Added, Status_ID, Lost_Removed_date, ISBN,PublishedYear)
VALUES  (2, '2022-01-10', 2, NULL, NULL,NULL),
        (1, '2023-02-11', 2, NULL, NULL,NULL),
        (3, '2023-01-03', 2, NULL, NULL,NULL),
        (2, '2022-01-04', 2, NULL, NULL,2002),
        (1, '2023-01-05', 2, NULL, NULL,NULL),
        (3, '2023-01-06', 2, NULL, NULL,NULL) ; 


-- inserting into itemcopy(-- lost(update the ISBN) -- lost(update the ISBN))
INSERT INTO ClientLibrary.ItemCopy (ItemID, Date_Added, Status_ID, Lost_Removed_date, ISBN,PublishedYear)
VALUES (1, '2020-01-02', 4, '2023-02-20', '984393sjdhdjs',1960),
        (2, '2022-01-12', 4, '2023-01-10', '48787437834hdh',1949),
        (3, '2023-01-22', 4, '2023-03-10', '094394kjfd',1969); 

 -- -- Inserting into  loan table
INSERT INTO ClientLibrary.Loan (MemberID, CopyID, Date_Taken_Out, Date_Due_Back, Date_Returned, FineAmount)
VALUES (1, 7, '2023-02-28', '2023-04-20', NULL, NULL), --overdue
         (1, 7, '2023-02-18', '2023-04-18', NULL, NULL), -- overdue
          (1, 7, '2023-03-10', '2023-03-14', '2023-03-16', NULL), -- returned 2 days late
          (1, 8, '2023-02-10', GETDATE()+3, NULL, NULL), -- due in 3 days
          (2, 8, '2023-01-10', GETDATE()+1, NULL, NULL), -- due in 1 days
          (2, 9, '2023-03-10', '2023-05-12', NULL, NULL), -- next month
          (2, 10, '2023-03-10', '2023-04-28', NULL, NULL), -- due few days 
          (1, 11, '2023-03-01', '2023-04-26', NULL, NULL), -- due few days
          (2, 12, '2023-03-10', '2023-03-20', NULL, NULL), -- overdue
           (2, 12, '2023-01-12', '2023-03-01', '2023-01-28', NULL); -- returned early
  

  -- this will test the TRG_UpdateFineAmount tigger and also pay part of loan own by a member
  -- payment of 10p made for loanid 1
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(1,1,0.10,GETDATE(),1);

-- payment of 35p made for loanid 2 
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(2,1,0.35,GETDATE(),2);

-- payment of 0.35p made for loanid 9
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(9,2,0.35,GETDATE(),2);

-- payment of 1.15p made for loanid 9
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(9,2,1.15,GETDATE(),2);

-- payment of 0.10p made for loanid 9
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(9,2,0.10,GETDATE()-5,2);

-- payment of 0.35p made for loanid 9
INSERT INTO  ClientLibrary.fine_repayment(loanID,MemberID,AmountPaid,PaymentDate,PaymentID)
VALUES(9,2,0.35,GETDATE()-3,2);

-- This updates the loan fine amount and balance for each loan daily
EXEC ClientLibrary.SP_DailyUpdateLoanFineAmount;  
-- to test the view and see the full list, the following code is used
SELECT * FROM ClientLibrary.VW_GetFullItemListDueSoon;
-- Testing the loan history view
SELECT * FROM ClientLibrary.VW_LoanHistory;
-- testing the Get Loan function
SELECT ClientLibrary.Func_GetLoansOnDate('2023-03-10') AS NumLoans;
-- viewing the OverDueLoanItems view
SELECT * FROM ClientLibrary.VW_OverDueLoanItems;
-- Testing the User-Defined Function the number of days the loan is overdue 
SELECT ClientLibrary.Func_CalculateOverdueFineAmount(1) as 'Fine Narrative';
-- testing the stored procedure(View that search item catalogue by matching character)
EXEC ClientLibrary.SP_SearchItemCatalogueByTitle 'O'; 


-- Start Of Access Control  

-- Creating different roles
--Admin Role
CREATE ROLE AdminRole;
-- Manager Role
CREATE ROLE ManagerRole;
-- Libarian Role
CREATE ROLE LibrarianRole;

-- Grant all access to the admin role
GRANT SELECT, INSERT, UPDATE, DELETE ON SCHEMA::ClientLibrary TO AdminRole;

-- Grant SELECT, INSERT, UPDATE access to the manager role
GRANT SELECT, INSERT, UPDATE ON SCHEMA::ClientLibrary TO ManagerRole;

-- Grant SELECT access to the Libarian role
GRANT SELECT, INSERT, UPDATE ON SCHEMA::ClientLibrary TO LibrarianRole; 

---
-- Creating an admin user
CREATE LOGIN AdminUser1 WITH PASSWORD = 'AdminThebdh01*';
-- Creating a Library user
CREATE LOGIN LibraryUser1 WITH PASSWORD = 'Libraryjhjs99&';
-- Creating a manager user
CREATE LOGIN ManagerUser1 WITH PASSWORD = 'ManagerThebdh03*'; 

--Login Access
CREATE USER AdminUser1 FOR LOGIN AdminUser1;
CREATE USER LibraryUser1 FOR LOGIN LibraryUser1;
CREATE USER ManagerUser1 FOR LOGIN ManagerUser1; 

-- Access role to users
-- Assign the AdminRole role to AdminUser1
ALTER ROLE AdminRole ADD MEMBER AdminUser1;

-- Assign the ManagerRole role to ManagerUser1
ALTER ROLE ManagerRole ADD MEMBER ManagerUser1;

-- Assign the ManagerRole role to LibraryUser1
ALTER ROLE LibrarianRole ADD MEMBER LibraryUser1;

-- End Of Access Control  

 --================================================================================================================
 --                         END OF TASK 1
 --================================================================================================================






 
 --================================================================================================================
 --                         START OF TASK 2
 --================================================================================================================
 -- using master
 USE master;
 -- create the database
 CREATE DATABASE PrescriptionsDB;
 -- Switch to the database 
 USE PrescriptionsDB;
-- Create a new schema
GO
CREATE SCHEMA Nhs;
GO 

/* QUESTION 1 */

-- Creating the Medical Practice table
CREATE TABLE Nhs.Medical_Practice
(
    PRACTICE_CODE NVARCHAR(10) NOT NULL,
    PRACTICE_NAME	NVARCHAR(100) NOT NULL,
    ADDRESS_1	NVARCHAR(60) NOT NULL,
    ADDRESS_2	NVARCHAR(60) ,
    ADDRESS_3	NVARCHAR(60) ,
    ADDRESS_4	NVARCHAR(60) ,
    POSTCODE NVARCHAR(10) NOT NULL
);
 
-- Creating the drugs table
CREATE TABLE Nhs.Drugs 
( 
    BNF_CODE NVARCHAR(20) NOT NULL,
    CHEMICAL_SUBSTANCE_BNF_DESCR NVARCHAR(100) NOT NULL,
    BNF_DESCRIPTION NVARCHAR(100) NOT NULL,
    BNF_CHAPTER_PLUS_CODE NVARCHAR(100) NOT NULL
);

-- Creating the drug table
CREATE TABLE Nhs.Prescriptions 
( 
    PRESCRIPTION_CODE NVARCHAR(10) NOT NULL,
    PRACTICE_CODE NVARCHAR(10) NOT NULL,
    BNF_CODE NVARCHAR(20) NOT NULL,
    QUANTITY NVARCHAR(10) NOT NULL,
    ITEMS  NVARCHAR(10) NOT NULL,
    ACTUAL_COST FLOAT NOT NULL
);
 
-- Add primary key to Drugs table
ALTER TABLE Nhs.DRUGS ADD PRIMARY KEY(BNF_CODE);

-- Add primary key to Medical_practice table
ALTER TABLE Nhs.Medical_Practice ADD PRIMARY KEY(practice_code);

-- Add primary key to Prescriptions table
ALTER TABLE Nhs.Prescriptions ADD PRIMARY KEY(Prescription_code);
 

-- add foreign contraint to the prescription table linking to the medical_practice table
ALTER TABLE Nhs.[Prescriptions]
ADD CONSTRAINT ck_fk_practice_code FOREIGN KEY (practice_code) REFERENCES Nhs.Medical_Practice (practice_code) ;

-- add foreign contraint to the prescription table linking to the drugs table
ALTER TABLE Nhs.[Prescriptions]
ADD CONSTRAINT ck_fk_bnf FOREIGN KEY ([BNF_CODE]) REFERENCES Nhs.Drugs([BNF_CODE]) ;

/* INSERTING INTO NHS TABLES FROM THE CSV FILES IMPORTED IN DBO TABLES THEN 
DROPPING THE DBO TABLES */

-- Medical table insert
INSERT INTO Nhs.Medical_Practice -- Nhs Schema
SELECT * FROM Dbo.Medical_Practice; -- dbo Schema

-- Drugs table insert
INSERT INTO Nhs.Drugs -- Nhs Schema
SELECT * FROM Dbo.Drugs; -- dbo Schema

-- Prescriptions table insert
INSERT INTO Nhs.Prescriptions   -- Nhs Schema
SELECT * FROM Dbo.Prescriptions; -- dbo Schema

-- Dropping the csv tables;
DROP TABLE Dbo.Medical_Practice;  -- dbo Schema
DROP TABLE Dbo.Drugs; -- dbo Schema
DROP TABLE Dbo.Prescriptions; -- dbo Schema


/* QUESTION 2 
Write a query that returns details of all drugs which are in the form of tablets or capsules. You can assume that all 
drugs in this form will have one of these words in the BNF_DESCRIPTION column. */

SELECT * 
FROM Nhs.Drugs
WHERE BNF_DESCRIPTION LIKE '%tablets%' 
OR BNF_DESCRIPTION LIKE '%capsules%';  
 
/* QUESTION 3
 Write a query that returns the total quantity for each of prescriptions – this is given by the number of items multiplied 
by the quantity. Some of the quantities are not integer values and your client has asked you to round the result to the nearest 
integer value. */

SELECT PRESCRIPTION_CODE, 
         ROUND(CAST(QUANTITY AS FLOAT) * CAST(ITEMS AS FLOAT), 0) AS TOTAL_QUANTITY
FROM Nhs.Prescriptions;


/* QUESTION 4 */
/* Write a query that returns a list of the distinct chemical substances which appear in the Drugs table 
(the chemical substance is listed in the CHEMICAL_SUBSTANCE_BNF_DESCR column) */

 SELECT DISTINCT CHEMICAL_SUBSTANCE_BNF_DESCR  
 FROM Nhs.DRUGS;


/* QUESTION 5 */
 /*
 Write a query that returns the number of prescriptions for each BNF_CHAPTER_PLUS_CODE, along with the average
  cost for that chapter code, and the minimum and maximum prescription costs for that chapter code. */

SELECT d.BNF_CHAPTER_PLUS_CODE,
        COUNT(*) [Number of Prescriptions],
        AVG(p.Actual_COST) [Average Cost],
        MIN(p.Actual_COST) [Minimum Cost],
        MAX(p.Actual_COST) [Maximum Cost]
FROM Nhs.PRESCRIPTIONS p
JOIN Nhs.DRUGS d ON p.BNF_CODE = d.BNF_CODE
GROUP BY d.BNF_CHAPTER_PLUS_CODE;
  

/* QUESTION 6 */
/* Write a query that returns the most expensive prescription prescribed by each practice, sorted in
descending order by prescription cost (the ACTUAL_COST column in the prescription table.) Return only
those rows where the most expensive prescription is more than £4000. You should include the practice 
name in your result. */
 
  
 SELECT m.practice_name [Practice Name], 
        p.ACTUAL_COST [Actual Cost]
 FROM Nhs.PRESCRIPTIONS p 
 JOIN Nhs.Medical_Practice m
 ON p.practice_code = m.practice_code
 WHERE p.ACTUAL_COST =  (SELECT max(ACTUAL_COST)
                          FROM Nhs.PRESCRIPTIONS 
                           WHERE practice_code = p.practice_code)
       AND  p.ACTUAL_COST >  4000
 ORDER BY p.ACTUAL_COST DESC;

 

 
 /* QUESTION 7 */

 /* You should also write at least five queries of your own and provide a brief explanation
of the results which each query returns. You should make use of all of the following at least once:
*/
 

/* return chemical substance that are 'Simeticone','Magnesium oxide','Omeprazole'
where the prescription cost is greater than the average prescription
*/

SELECT d.CHEMICAL_SUBSTANCE_BNF_DESCR,
        p.practice_code [Practice Code],
        m.practice_name [Practice Name],
        p.quantity, 
        p.items,
        p.Actual_COST
        ,(SELECT AVG(ACTUAL_COST) FROM Nhs.PRESCRIPTIONS) [Average Cost]
FROM Nhs.Drugs d
JOIN Nhs.PRESCRIPTIONS p 
ON d.bnf_code = p.bnf_code
JOIN Nhs.Medical_Practice m
ON p.practice_code = m.practice_code
WHERE d.CHEMICAL_SUBSTANCE_BNF_DESCR IN ('Simeticone','Magnesium oxide','Omeprazole')
AND P.ACTUAL_COST > (SELECT AVG(ACTUAL_COST) FROM Nhs.PRESCRIPTIONS)


 
/* Write a query that returns the total prescription and the name of the practice for drug
Simvastatin and order the number of prescription in descending order */

SELECT  m.PRACTICE_NAME, 
        COUNT(*) AS [TOTAL PRESCRIPTIONS]
FROM Nhs.Medical_Practice m
JOIN Nhs.Prescriptions p ON m.PRACTICE_CODE = p.PRACTICE_CODE
WHERE EXISTS (
                SELECT 1 
                FROM Nhs.Drugs d
                WHERE d.BNF_CODE = p.BNF_CODE
                AND d.CHEMICAL_SUBSTANCE_BNF_DESCR = 'Simvastatin'
)
GROUP BY m.PRACTICE_NAME
ORDER BY COUNT(*) DESC;



-- JOINS

/* Return the average actual cost and total actual cost for every practice, order the 
  total actually cost in descending order rounded to 2 decimal places  */
 
 
SELECT mp.PRACTICE_CODE, mp.PRACTICE_NAME, 
       ROUND(AVG(p.ACTUAL_COST),2) AS [Average Actual Cost],
       ROUND(SUM(p.ACTUAL_COST),2) AS [Total Actual Cost]
FROM Nhs.Medical_Practice mp
JOIN Nhs.Prescriptions p ON mp.PRACTICE_CODE = p.PRACTICE_CODE
GROUP BY mp.PRACTICE_CODE, mp.PRACTICE_NAME
ORDER BY [Total Actual Cost] DESC;


/* A query that finds the medical practices that have prescribed the highest number of items, 
ordered by the number of items in descending order.*/

SELECT 
        mp.PRACTICE_CODE, mp.PRACTICE_NAME, COUNT(p.ITEMS) AS Total_Items
FROM Nhs.Medical_Practice mp
JOIN Nhs.Prescriptions p ON mp.PRACTICE_CODE = p.PRACTICE_CODE
GROUP BY mp.PRACTICE_CODE, mp.PRACTICE_NAME
ORDER BY Total_Items DESC;



 -- System functions
/* Return all the rows where the CHEMICAL_SUBSTANCE_BNF_DESCR 
starts with B and ends with a vowel */

SELECT * FROM Nhs.DRUGS 
 WHERE LEFT(CHEMICAL_SUBSTANCE_BNF_DESCR,1) = 'B' -- chemical starts with B
 AND RIGHT(CHEMICAL_SUBSTANCE_BNF_DESCR,1) IN ('A','E','I','O','U'); -- ends with any of the 5 letters

 /* Return the distinct BNF Chapter plus code from the drug table and the length of each code
 displaying the longest first */

SELECT DISTINCT BNF_CHAPTER_PLUS_CODE, -- selects unique benf chapter code
        LEN(BNF_CHAPTER_PLUS_CODE) [Code Length] -- counts the length
FROM Nhs.DRUGS
ORDER BY LEN(BNF_CHAPTER_PLUS_CODE) DESC -- order the length. Highest to lowest

 /* Write a query that returns the  Practice that prescribed more than $10,000, order it by the 
 amount prescribed in descending and also the total prescribed should be in the nearest integer  */

 SELECT p.practice_code [Practice Code],
 m.practice_name [Practice Name], 
 ROUND(SUM(ACTUAL_COST),0) [Total Prescribed]
 FROM Nhs.PRESCRIPTIONS p 
 JOIN Nhs.Medical_Practice m
 ON p.practice_code = m.practice_code
GROUP BY p.practice_code,m.practice_name 
HAVING SUM(ACTUAL_COST) > 10000
ORDER BY SUM(ACTUAL_COST) DESC

/* Write a query that the BNF description and the total prescription for it. Where the 
presciption count is greater than 400, order the count in descending order   */

SELECT d.BNF_DESCRIPTION, COUNT(*) AS Total_Prescriptions
FROM Nhs.Drugs d
JOIN Nhs.Prescriptions p ON d.bnf_code = p.bnf_code
GROUP BY d.BNF_DESCRIPTION
HAVING COUNT(*) > 400
ORDER BY Total_Prescriptions DESC;
 --================================================================================================================
 --                         END OF TASK 2
 --================================================================================================================